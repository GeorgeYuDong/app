#include <stdio.h>
#include <locale.h>
#include <wchar.h>

using namespace std;

int main(int argc, char const *argv[])
{
	unsigned int a = 100;
	printf("%d\n", a);

	//联想记忆，具象记忆，想象记忆，多感官记忆。记忆不仅仅是大脑的事情
	//计算机是一门科学，站在科学的角度看问题
	//最重要的是耐心，坚持，现在我有大把的时间完成这些学习
	//要把C语言中文网这些课程都学完，除了单片机，有余力再学
	//排除一切干扰，静心掌握基础知识

	//puts加引号写成3行，形式上分割，计算机内部会合并，不分割
	//C++包含了C，或者说C++扩展了C
	//C++,早期就是带类的C，支持面向对象编程和泛型编程
	//没有诞生单独的C++编译器，而是在C的基础上支持C++的新特性
	//硬盘中一部分空间存放内存中暂时不用的数据，这部分空间叫做虚拟内存
	//小写字母的ASCII码大于大写字母的ASCII码
	//GB2312->GBK->GB18030,后面的包含前面的,GB18030最大
	//编码要考虑内存使用率
	//采用变长编码方式(GB2312,GBK,BIG5)：
	//ASCII码用一个字节即可,本国用两个字节，极少使用的字符用三到四个字节存储
	/*从整体上讲，GB2312 和 GBK 的编码方式一致，具体为：
对于 ASCII 字符，使用一个字节存储，并且该字节的最高位是 0，这和 ASCII 编码是一致的，所以说 GB2312 完全兼容 ASCII。
对于中国的字符，使用两个字节存储，并且规定每个字节的最高位都是 1。*/
	//GB18030采用1,2,4个字节去编码,处理效率低于GBK,GB2312
	//GB2312编码和GBK编码，将中文存储到计算机标题里面有具体说明
	//windows默认使用GBK，内核在处理字符时，一般会将地区编码（GBK等非unicode）转化为unicode编码再进行下一步处理
	//GBK,GB2312等制定时就考虑了编码问题，说是字符集也无所谓
	//unicode只管制定字符编号，至于怎么存储，那是字符编码的事情。
	/*UFT-8：一种变长的编码方案，使用 1~6 个字节来存储；
      UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储； 
      UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。*/
	//unicode字符集，将全世界的文字存储到计算机，这个需要多看几遍，多研究几遍
	//加法器也有多种实现方式，对外就是一个加法的接口，也是一种封装
	//C语言是一门通用性的语言，没有针对某个领域进行优化
	//驱动，操作系统内核，单片机，组件和服务，编写PHP扩展，
	//算法，对效率要求较高，可以使用C语言来做
	//如何来掌握那么多的知识点，就要靠多练习，靠条件反射，而不是靠计算。	
	//库分两种：标准库，第三方库
	//JAVA等语言，学了标准库可以做出东西来.C语言应用层的开发用不上
	//数据结构，算法，内存，线程，进程，通信，操作系统等底层知识，需要C语言基础
	//学了C语言会让你有架构师的思维,会站得低看得远，避免低级错误
	//数据结构等要理解概念，不要深入细节，尽早跳出来做应用开发，找到成就感
	//C语言的作用让你入门，了解编程语言的基础，强化编程思维，为职业生涯打下坚实基础，而不是用她来做实际开发
	//C语言支持的特性少，开发效率低。JAVA等相反。但运行效率高
	//大量编写代码，不断实践，丰富自己的经验，强化编程思维,这也是我目前缺少的
	//培训班只要入门了，就达到目标了
	//搜索引擎和学长学姐
	//全角和半角要注意,要用半角
	//编译和链接生成最终的可执行文件
	//编译：gcc main.c -o ./out/main 可以输出到其他目录
	//gcc -c main.c 将源文件编译成目标文件,生成main.o,编译源文件，但不链接
	//gcc -c main.c -o a.o,-o选项自定义目标文件名字,-o用于指定输出文件名
	//链接：gcc main.o生成a.out,生成可执行文件
	//C89,C99,C11,没有一个公司或官方机构
	//GCC,LLVM/Clang更新及时，支持C11,微软更新比较慢
	//函数是一段可以重复使用的代码
	//头文件只是函数说明，告诉我们如何用，函数本身在链接时才会找到
	//头文件与C文件都是文本文件无本质区别
	//数据类型指明数据的含义，同时指明数据的长度
	//强类型语言不能赋其他类型的数据。弱类型的语言没有这种限制，可以是多种数据类型
	//printf，是print format的缩写，输出格式的缩写
	//puts会自动加换行，printf不会
	//short占用更少内存(小于等于int),两个字节。long占用更多字节,可能与int相同，也可能大于int
	//16位,2,2,4。32位,2,4,4.short,int,long
	//unix系统下long为8字节
	//%hd:short int. %ld:long int。d是decimal的意思
	puts("a"
		 "bl"
		 "ck");
	printf("%d\n",sizeof a); //输出的是十进制有符号数
	char c = '@';
	printf("%c\n",c);	
	long b = 1234566789;
	printf("short b:%hd\n", b);//长整型用短整型显示出来，数据就不对了
	int d = 0b11; //0B或者0b为二进制写法。并非所有编译器都支持该写法
	//高版本GCC支持,Clang支持
	printf("%#o\n",d);//输出加#，把输出格式的前缀也显示出来	
	int e = 0x15; //16进制写法,以0x开头
	printf("%#x\n",e);	
	int f = 015; //8进制写法,以0开头
	printf("%#o\n",f);//输出的是无符号数	

	//符号位0-整数，1-负数		
	//unsigned表示不用设置符号位,为0的时候，没有前缀，不管是多少进制
	unsigned int g = 0;
	printf("%#x\n",g);	
	printf("%lu\n",g);//输出十进制无符号数	
	//我管你在定义时是有符号数还是无符号数呢，我只关心内存，有符号数也可以按照无符号数输出，无符号数也可以按照有符号数输出，至于输出结果对不对，那我就不管了，你自己承担风险
	//内存的最高位作为符号位，0-正数，1-负数
	unsigned h = 0x80000000; //2的31次方-2147483648	
	printf("h:%d\n",h);	
	printf("h1:%u\n",h);	
	//加法由硬件直接支持
	//人类立即计算完成，用的不是计算，是记忆
	//简化硬件电路，就是不区分符号位和数值位
    //代价是有符号数在存储和读取时都要进行转化
	//原码是数的二进制的本来形式，只是加上了符号位，符号位不参与数值位的运算
	//反码是数的符号位不变，正数数值位不变，负数数值位取反
	//补码是正数不变，负数的补码是其反码加1，补码是在反码的基础上打了个补丁，所以叫补码
	//内存中，整数采用补码存储。当读取整数时，需要采用逆向转换，将补码转换为原码
	//内存存储的是补码,硬盘存储的也是补码,数字统一用补码存储
	int m = -0x1;//有符号数，加载到内存里面这个值的补码是0xffffffff
	printf("M:%#x\n", m);//以无符号方式输出,则认为是正数，不需转换，直接输出
	printf("M1:%d\n", m);//转化成有符号数输出，转化成原码输出，原码是-1	
	printf("M2:%u\n", m);//全部是1，数值为4294967295
	//C语言定义变量，大小写敏感

	unsigned short n = 0xffff;//无符号数，内存里面补码和原码一样
	printf("n:%hd\n", n); //以有符号数输出，最高位为1，转换成原码后,值为-1

	unsigned short N = 0x0100; //值为256
	printf("N:%hd\n", N); //以无符号数输出，最高位为0，原先是多少就是多少 

	unsigned short M = 0x8000; //值为-32768
	printf("M:%hd\n", M); //以有符号数输出，最高位为1,转换成原码后，值为-32768 

	//负数在存储前要先转换为补码，-128的补码为0x80
	short M3 = -0x80; //值为-128,原码和补码一致,一个字节最大正整数为127
	printf("M3:%hd\n", M3); //以有符号数输出，最高位为1,转换成原码后，值为-32768 
	printf("M3_1:%hx\n", M3); //以有符号数输出，最高位为1,转换成原码后，值为-32768 

	//如果直接采用原码存储，多了正零和负零，-128就没有了,是一个规定
	//对于有符号数，以十进制输出时，是否该转换，由补码最高位是否为1进行判断

	//科学严谨的态度对待学习，形成体系。之前我缺乏的就是这种科学严谨，学习的东西不成体系，没有严丝合缝的逻辑，太过于主观臆断
	//小数:float-4个字节，double-8个字节.表示法:0.5E7=0.5*10的7次方
	//0.5-尾数,7-指数
	//%lf-double类型,%e,%E,%le,%lE,指数形式输出
	float M4 = 0.302;
	printf("M4:%e\n", M4); //
	printf("M4_1:%le\n", M4); //
	printf("M4_2:%lE\n", M4); //
	printf("M4_3:%E\n", M4); //
	printf("M4_4:%f\n", M4); //lf,f默认保留6位小数，少补，多则四舍五入
	printf("M4_5:%lf\n", M4); //以指数形式输出

	float M5 = 0.123e-2;
	printf("M5_1:%E\n", M5); //以指数形式输出
	printf("M5_2:%e\n", M5); //以指数形式输出
	printf("M5_3:%f\n", M5); //以指数形式输出
	printf("M5_4:%lf\n", M5); //以指数形式输出

	float M6 = 0.12345678;
	printf("M6_1:%lf\n", M6); //以指数形式输出
	printf("M6_2:%f\n", M6); //以指数形式输出

	float M7 = 123.101;
	printf("M7_1:%f\n", M7); //不能精确输出

	//%f,%e,默认保留6位小数，只包括小数部分
	//%g,默认最多保留6位有效数字，包括整数和小数部分，会进行四舍五入,不足不会强加0

	float M8 = 123.6;
	printf("M8_1:%g\n", M8); //默认最多保留6位有效数字
	printf("M8_1:%lg\n", M8); //默认最多保留6位有效数字

	float M9 = 30000000000;
	printf("M9_1:%g\n", M9); //指数形式表示用e，%g
	printf("M9_2:%G\n", M9); //用大E

	//数字的默认类型。整数，默认类型是int,小数默认类型是double
	int M10 = 100L;
	printf("M10:%d\n", sizeof M10); //用大E
	printf("M10:%d\n", sizeof (long)); //用大E

	double M11 = 18.6F;
	printf("M11:%d\n", sizeof M11); //用大E

	float M12 = 0.2L;
	printf("M12:%d\n", sizeof M12); //用大E

	//默认是double,需转换为float
	float M13 = 52.55f;

	//小数赋值给整数，小数部分直接丢弃，不进行四舍五入
	int M14 = 19.632;	
	printf("M14:%d\n", M14); //

	//整数赋值给小数，小数位补0即可
	float M15 = 1000;
	printf("M15:%lf\n", M15); //

	//short,int,long类型的整数使用定点数存储格式
	//float,double使用浮点数格式存储小数
	//计算机的设计是一门艺术，很多实用技术都是权衡和妥协的结果
	//整数 也可以使用 浮点数格式存储
	//小数 也可以使用 定点数格式存储
	//这是 数值范围 和 数值精度 两项重要指标之间平衡的结果
	//定点数取值范围太小
	//32位的话，取值范围2的16次方到2的-16次方
	//按照指数形式存储，节省内存，非常直观,即浮点数方案
	//换句话说，将小数转换成浮点格式后，小数点的位置发生了浮动（移动），并且浮动的位数和方向由 指数值 决定，所以我们将这种表示小数的方式称为浮点数。
	//exponent 大于零，mantissa 中的小数点右移 exponent 位即可还原小数的值；反之，左移
	//内存中只要存储符号位，尾数位，指数位
	//尾数部分正整数为1，不需存，只需存小数部分
	//要学会吸收知识，不仅仅去看，更要去用心，去理解，去思考,去连接，去融汇贯通
	//32位，1-符号位, 8-指数位（127）,23-尾数位
	//64位, 1-符号位, 11-指数位（1023），52-尾数位
	//正确使用大脑，健康使用大脑
	//itoa在C99标准中指定为不可用函数，有些编译器可能不支持
	//小数部分乘二取整，不一定能转换成有限位数的二进制，末位为5才能转换成有限位数的二进制
	//尾数部分有限，不能容纳的就四舍五入。
	//float支持精度位7-8位，double支持精度位15-16位
	//与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。
	//指数 exponent 如何放入内存:
	//exp = 2的指数-1次方  - 1+ 指数值exponent
	//浮点，小数点位有浮动
	//指数二进制位全为0，非规格化浮点数：
	//指数不全为0或者1，为规格化浮点数
	//指数全为1，按特殊值对待


	//符号位，指数位，尾数位
	//指数位：指数值+中间值
	//尾数位:不足补0

	//指数exp所有为0，尾数隐含整数部分变成0 ,非规格化浮点数
	//真实的exponet=1-exp
	//float:1-127 = -126,恒定值
	//doouble:1-1023=-1022,恒定值
	//此种情况尾数为0时，浮点数为0，正负0

	//ceil,向上舍入，-1.324=-1,1.234=2
	//floor,向下舍入，1.324=1，-1.324=-2
	//向0舍入，多余位数直接去掉，类型转换就是这种,-1.234=-1,1.324=1
	//损失精度，换取取值范围，就是浮点数思想
	//指数全为1，尾数为0，按符号位，表示正负无穷大
	//尾数不全为0，无效的数字，或者数字未经初始化
	//小数部分：乘2取整


	float  M16 = 4.25;
	printf("%f\n",M16 );

	//char类型不能包含ASCII编码之外的字符,不能包含全角字符
	//putchar,%c	
	//ASCII码表将字符和整数连接了起来
	char web_url[] = "www.baidu.com";

	//put string,puts
	puts(web_url);

	//wchar宽字符
	//putwchar
	//wprintf,加前缀L，宽字符
	//对字符串而言,%ls，前缀加L代表宽字符串
	//wchar_t类型的宽字符和宽字符串使用utf-16或者utf-32编码
	//char类型的窄字符使用ASCII编码
	//char类型的窄字符串不使用ASCII编码
	//本地编码GBK,utf-8编码。窄字符编码(多字节)
	//Gcc使用和源文件相同的编码，微软编译器使用本地编码
	//编码字符集是站在存储和传输的角度，运行字符集是站在处理或者操作的角度
	//编码字符集是存储或者网络传输用，编码要尽量节省存储空间,方便跨国交流，采用utf-8
	//程序运行时，要选用提高处理速度的编码，UTF-16，UTF-8
	//字符除了使用本身来表示，也可以使用编码值来表示。称为转义字符
	//\,表示8进制，\x表示16进制	
	char str1[] = "\x31\x32\x61\x62";
	printf("str1:%s\n",str1 );
	//转义字符初衷用于ASCII,8进制形式最多跟三个数字,最大\177
	//16进制跟两位数字，最大取值\x7f

	//对于0-31为控制字符，无法从键盘输入，只能使用转义字符，定义了简写形式
	//\r回车，\n换行，\t tab作用,占位

	//单引号\',双引号\''，反斜杠\\
	//标识符:字母，数字，下划线，组成,第一个字符不能是数字.大小写敏感
	//32个关键字,特殊意义
	//注释不能嵌套
	//表达式必须有一个结果，printf返回字符个数
	//语句以分号结束
	//加减乘除，+取余
	//整数相除得整数，有小数，则得double类型
	//取余的结果，正负由%左边的数决定
	printf("100取余-12:%d\n",100%-12);
	//a+=8, a -= 10; 简写形式
	//全局变量默认初始值为0,局部变量没有默认值，需手动初始化
	//?:是三目运算符，+-是双目运算符,++--是单目运算符

	wchar_t M18 = L'A';	
	wchar_t M19 = L'9';	
	setlocale(LC_ALL,"zh-CN");

	putwchar(M18);
	putwchar(L'\n');
	wprintf(L"M18:%lc\n",M18);
	wprintf(L"M18_1:%lc\n",M19);

	//char和short转换为int类型参与运算
	//float转换为double类型进行运算
	//强制类型转换风险比较高
	//puts,putchar,printf
	//输出默认右对齐，加-代表左对齐
	//.precision是补0，不是补空格,跟没有点的情况不一样
	//%.0f只输出整数部分，%#.0f
	//输出的命门在于缓存
	//linux加换行符会输出，windows不会
	//scanf 是scan format 的缩写，格式化扫描，也就是从键盘获取输入
	//scanf 根据地址，把读取到的数据写入到内存中去

	//%p是输出地址符,输出的地址为虚拟地址,内存管理的需要
	//一看觉得懂，一问就打鼓，一用就糊涂。
	//而网络协议就是值得你学习，而且是到 40 岁之后依然有价值的知识。
	//从熟悉入手，从点到面学习，从	云计算，容器，微服务等新领域学习
 	//看似最枯燥、最基础的东西往往具有最长久的生命力。
	//背诵，烂熟于心，往细里问又发现懂得没有那么透彻
	//

	int M20 = 20;
	printf("%p\n",&M20);

	printf("%#x\n",&M20 );

	//







	//class-loader,java类加载机制
	//java编程思维，编程感觉
	//javac *.java 生成.class文件
	//java HelloWorld,不要加.java后缀
	//



	return 0;
}